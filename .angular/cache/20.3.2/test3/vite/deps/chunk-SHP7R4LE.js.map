{
  "version": 3,
  "sources": ["../../../../../../node_modules/prosemirror-schema-list/dist/index.js", "../../../../../../node_modules/ngx-editor/fesm2022/ngx-editor-utils.mjs", "../../../../../../node_modules/ngx-editor/fesm2022/ngx-editor-schema.mjs"],
  "sourcesContent": ["import { findWrapping, ReplaceAroundStep, canSplit, liftTarget, canJoin } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1, validate: \"number\" } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to);\n        if (!range)\n            return false;\n        let tr = dispatch ? state.tr : null;\n        if (!wrapRangeInList(tr, range, listType, attrs))\n            return false;\n        if (dispatch)\n            dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nTry to wrap the given node range in a list of the given type.\nReturn `true` when this is possible, `false` otherwise. When `tr`\nis non-null, the wrapping is added to that transaction. When it is\n`null`, the function only queries whether the wrapping is\npossible.\n*/\nfunction wrapRangeInList(tr, range, listType, attrs = null) {\n    let doJoin = false, outerRange = range, doc = range.$from.doc;\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n        // Don't do anything if this is the top of the list\n        if (range.$from.index(range.depth - 1) == 0)\n            return false;\n        let $insert = doc.resolve(range.start - 2);\n        outerRange = new NodeRange($insert, $insert, range.depth);\n        if (range.endIndex < range.parent.childCount)\n            range = new NodeRange(range.$from, doc.resolve(range.$to.end(range.depth)), range.depth);\n        doJoin = true;\n    }\n    let wrap = findWrapping(outerRange, listType, attrs, range);\n    if (!wrap)\n        return false;\n    if (tr)\n        doWrapInList(tr, range, wrap, doJoin, listType);\n    return true;\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType, itemAttrs) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : undefined;\n        if (!canSplit(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nActs like [`splitListItem`](https://prosemirror.net/docs/ref/#schema-list.splitListItem), but\nwithout resetting the set of active marks at the cursor.\n*/\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n    let split = splitListItem(itemType, itemAttrs);\n    return (state, dispatch) => {\n        return split(state, dispatch && (tr => {\n            let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n            if (marks)\n                tr.ensureMarks(marks);\n            dispatch(tr);\n        }));\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = liftTarget(range);\n    if (target == null)\n        return false;\n    tr.lift(range, target);\n    let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);\n    if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)\n        tr.join($after.pos);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n        .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, splitListItemKeepMarks, wrapInList, wrapRangeInList };\n", "const isNil = (val) => {\n    return typeof val === 'undefined' || val === null;\n};\n\nconst camelToDashed = (str) => {\n    return str.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);\n};\nconst cleanObject = (obj) => {\n    const cleanObj = {};\n    Object.keys(obj).forEach((prop) => {\n        if (obj[prop] && typeof obj[prop] === 'string') {\n            cleanObj[prop] = obj[prop];\n        }\n    });\n    return cleanObj;\n};\nconst toStyleString = (obj) => {\n    const styles = cleanObject(obj);\n    return Object.entries(styles).map(([k, v]) => `${camelToDashed(k)}:${v}`).join(';');\n};\n\nclass NgxEditorError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\n\nconst uniq = () => {\n    const timeStamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 7);\n    return `${timeStamp}${random}`;\n};\n\nconst clamp = (value, min, max) => {\n    return Math.min(Math.max(value, min), max);\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxEditorError, clamp, isNil, toStyleString, uniq };\n\n", "import * as sl from 'prosemirror-schema-list';\nimport { toStyleString } from 'ngx-editor/utils';\nimport { Schema } from 'prosemirror-model';\n\n// :: MarkSpec A link. Has `href` and `title` attributes. `title`\n// defaults to the empty string. Rendered and parsed as an `<a>`\n// element.\nconst link = {\n    attrs: {\n        href: {},\n        title: { default: null },\n        target: { default: '_blank' },\n    },\n    inclusive: false,\n    parseDOM: [\n        {\n            tag: 'a[href]',\n            getAttrs(dom) {\n                return {\n                    href: dom.getAttribute('href'),\n                    title: dom.getAttribute('title'),\n                    target: dom.getAttribute('target'),\n                };\n            },\n        },\n    ],\n    toDOM(node) {\n        const { href, title, target } = node.attrs;\n        return ['a', { href, title, target }, 0];\n    },\n};\n// :: MarkSpec An emphasis mark. Rendered as an `<em>` element.\n// Has parse rules that also match `<i>` and `font-style: italic`.\nconst em = {\n    parseDOM: [\n        { tag: 'i' },\n        { tag: 'em' },\n        { style: 'font-style=italic' },\n    ],\n    toDOM() {\n        return ['em', 0];\n    },\n};\n// :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules\n// also match `<b>` and `font-weight: bold`.\nconst strong = {\n    parseDOM: [\n        { tag: 'strong' },\n        // This works around a Google Docs misbehavior where\n        // pasted content will be inexplicably wrapped in `<b>`\n        // tags with a font-weight normal.\n        {\n            tag: 'b',\n            getAttrs: (dom) => {\n                return dom.style.fontWeight !== 'normal' && null;\n            },\n        },\n        {\n            style: 'font-weight',\n            getAttrs: (value) => {\n                return (/^(?:bold(?:er)?|[5-9]\\d{2,})$/).test(value) && null;\n            },\n        },\n    ],\n    toDOM() {\n        return ['strong', 0];\n    },\n};\n// :: MarkSpec Code font mark. Represented as a `<code>` element.\nconst code = {\n    parseDOM: [\n        { tag: 'code' },\n    ],\n    toDOM() {\n        return ['code', 0];\n    },\n};\n// :: MarkSpec An underline mark. Rendered as an `<u>` element.\n// Has parse rules that also match `text-decoration: underline`.\nconst u = {\n    parseDOM: [\n        { tag: 'u' },\n        {\n            style: 'text-decoration=underline',\n            consuming: false,\n        },\n    ],\n    toDOM() {\n        return ['u', 0];\n    },\n};\n// :: MarkSpec An underline mark. Rendered as an `<s>` element.\n// Has parse rules that also match `strike`, `del` tag and css property `text-decoration: line-through`.\nconst s = {\n    parseDOM: [\n        { tag: 's' },\n        { tag: 'strike' },\n        { style: 'text-decoration=line-through' },\n    ],\n    toDOM() {\n        return ['s', 0];\n    },\n};\nconst textColor = {\n    attrs: {\n        color: {\n            default: null,\n        },\n    },\n    parseDOM: [\n        {\n            style: 'color',\n            getAttrs: (value) => {\n                return { color: value };\n            },\n        },\n    ],\n    toDOM(mark) {\n        const { color } = mark.attrs;\n        return ['span', { style: `color:${color};` }, 0];\n    },\n};\nconst textBackgroundColor = {\n    attrs: {\n        backgroundColor: {\n            default: null,\n        },\n    },\n    parseDOM: [\n        {\n            style: 'background-color',\n            getAttrs: (value) => {\n                return { backgroundColor: value };\n            },\n        },\n    ],\n    toDOM(mark) {\n        const { backgroundColor } = mark.attrs;\n        return ['span', { style: `background-color:${backgroundColor};` }, 0];\n    },\n};\nconst sup = {\n    attrs: {},\n    parseDOM: [\n        { tag: 'sup' },\n        { style: 'vertical-align=super' },\n    ],\n    toDOM() {\n        return ['sup', 0];\n    },\n};\nconst sub = {\n    attrs: {},\n    parseDOM: [\n        { tag: 'sub' },\n        { style: 'vertical-align=sub' },\n    ],\n    toDOM() {\n        return ['sub', 0];\n    },\n};\nconst marks = {\n    link,\n    em,\n    strong,\n    code,\n    u,\n    s,\n    text_color: textColor,\n    text_background_color: textBackgroundColor,\n    sup,\n    sub,\n};\n\nconst doc = {\n    content: 'block+',\n};\n// :: NodeSpec The text node.\nconst text = {\n    group: 'inline',\n};\n// :: NodeSpec A plain paragraph textblock. Represented in the DOM\n// as a `<p>` element.\nconst paragraph = {\n    content: 'inline*',\n    group: 'block',\n    attrs: {\n        align: {\n            default: null,\n        },\n        indent: {\n            default: null,\n        },\n    },\n    parseDOM: [\n        {\n            tag: 'p',\n            getAttrs(dom) {\n                const { textAlign } = dom.style;\n                const align = dom.getAttribute('align') || textAlign || null;\n                const indent = dom.getAttribute('data-indent') || null;\n                return {\n                    align,\n                    indent: parseInt(indent, 10) || null,\n                };\n            },\n        },\n    ],\n    toDOM(node) {\n        const { align, indent } = node.attrs;\n        const styles = {\n            textAlign: align !== 'left' ? align : null,\n            marginLeft: indent !== null ? `${indent * 40}px` : null,\n        };\n        const style = toStyleString(styles) || null;\n        const attrs = {\n            style,\n            'data-indent': indent ?? null,\n        };\n        return ['p', attrs, 0];\n    },\n};\n// :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.\nconst blockquote = {\n    content: 'block+',\n    group: 'block',\n    defining: true,\n    attrs: {\n        indent: {\n            default: null,\n        },\n    },\n    parseDOM: [\n        {\n            tag: 'blockquote',\n            getAttrs(dom) {\n                const indent = dom.getAttribute('data-indent') || null;\n                return {\n                    indent: parseInt(indent, 10) || null,\n                };\n            },\n        },\n    ],\n    toDOM(node) {\n        const { indent } = node.attrs;\n        const styles = {\n            marginLeft: indent !== null ? `${indent * 40}px` : null,\n        };\n        const style = toStyleString(styles) || null;\n        const attrs = {\n            style,\n            'data-indent': indent ?? null,\n        };\n        return ['blockquote', attrs, 0];\n    },\n};\n// :: NodeSpec A horizontal rule (`<hr>`).\nconst horizontalRule = {\n    group: 'block',\n    parseDOM: [{ tag: 'hr' }],\n    toDOM() {\n        return ['hr'];\n    },\n};\n// :: NodeSpec A heading textblock, with a `level` attribute that\n// should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n// `<h6>` elements.\nconst heading = {\n    attrs: {\n        level: {\n            default: 1,\n        },\n        align: {\n            default: null,\n        },\n        indent: {\n            default: null,\n        },\n    },\n    content: 'inline*',\n    group: 'block',\n    defining: true,\n    parseDOM: [\n        {\n            tag: 'h1',\n            getAttrs(dom) {\n                const { textAlign } = dom.style;\n                const align = dom.getAttribute('align') || textAlign || null;\n                const indent = dom.getAttribute('data-indent') || null;\n                return {\n                    level: 1,\n                    align,\n                    indent: parseInt(indent, 10) || null,\n                };\n            },\n        },\n        {\n            tag: 'h2',\n            getAttrs(dom) {\n                const { textAlign } = dom.style;\n                const align = dom.getAttribute('align') || textAlign || null;\n                const indent = dom.getAttribute('data-indent') || null;\n                return {\n                    level: 2,\n                    align,\n                    indent: parseInt(indent, 10) || null,\n                };\n            },\n        },\n        {\n            tag: 'h3',\n            getAttrs(dom) {\n                const { textAlign } = dom.style;\n                const align = dom.getAttribute('align') || textAlign || null;\n                const indent = dom.getAttribute('data-indent') || null;\n                return {\n                    level: 3,\n                    align,\n                    indent: parseInt(indent, 10) || null,\n                };\n            },\n        },\n        {\n            tag: 'h4',\n            getAttrs(dom) {\n                const { textAlign } = dom.style;\n                const align = dom.getAttribute('align') || textAlign || null;\n                const indent = dom.getAttribute('data-indent') || null;\n                return {\n                    level: 4,\n                    align,\n                    indent: parseInt(indent, 10) || null,\n                };\n            },\n        },\n        {\n            tag: 'h5',\n            getAttrs(dom) {\n                const { textAlign } = dom.style;\n                const align = dom.getAttribute('align') || textAlign || null;\n                const indent = dom.getAttribute('data-indent') || null;\n                return {\n                    level: 5,\n                    align,\n                    indent: parseInt(indent, 10) || null,\n                };\n            },\n        },\n        {\n            tag: 'h6',\n            getAttrs(dom) {\n                const { textAlign } = dom.style;\n                const align = dom.getAttribute('align') || textAlign || null;\n                const indent = dom.getAttribute('data-indent') || null;\n                return {\n                    level: 6,\n                    align,\n                    indent: parseInt(indent, 10) || null,\n                };\n            },\n        },\n    ],\n    toDOM(node) {\n        const { level, align, indent } = node.attrs;\n        const styles = {\n            textAlign: align !== 'left' ? align : null,\n            marginLeft: indent !== null ? `${indent * 40}px` : null,\n        };\n        const style = toStyleString(styles) || null;\n        const attrs = {\n            style,\n            'data-indent': indent ?? null,\n        };\n        return [`h${level}`, attrs, 0];\n    },\n};\n// :: NodeSpec A code listing. Disallows marks or non-text inline\n// nodes by default. Represented as a `<pre>` element with a\n// `<code>` element inside of it.\nconst codeBlock = {\n    content: 'text*',\n    marks: '',\n    group: 'block',\n    code: true,\n    defining: true,\n    parseDOM: [\n        {\n            tag: 'pre',\n            preserveWhitespace: 'full',\n        },\n    ],\n    toDOM() {\n        return ['pre', ['code', 0]];\n    },\n};\n// :: NodeSpec A hard line break, represented in the DOM as `<br>`.\nconst hardBreak = {\n    inline: true,\n    group: 'inline',\n    selectable: false,\n    parseDOM: [{ tag: 'br' }],\n    toDOM() {\n        return ['br'];\n    },\n};\n// :: NodeSpec An inline image (`<img>`) node. Supports `src`,\n// `alt`, and `href` attributes. The latter two default to the empty\n// string.\nconst image = {\n    inline: true,\n    attrs: {\n        src: {},\n        alt: { default: null },\n        title: { default: null },\n        width: { default: null },\n    },\n    group: 'inline',\n    draggable: true,\n    parseDOM: [\n        {\n            tag: 'img[src]',\n            getAttrs(dom) {\n                return {\n                    src: dom.getAttribute('src'),\n                    title: dom.getAttribute('title'),\n                    alt: dom.getAttribute('alt'),\n                    width: dom.getAttribute('width'),\n                };\n            },\n        },\n    ],\n    toDOM(node) {\n        const { src, alt, title, width } = node.attrs;\n        return ['img', { src, alt, title, width }];\n    },\n};\nconst listItem = {\n    ...sl.listItem,\n    content: 'paragraph block*',\n};\nconst orderedList = {\n    ...sl.orderedList,\n    content: 'list_item+',\n    group: 'block',\n};\nconst bulletList = {\n    ...sl.bulletList,\n    content: 'list_item+',\n    group: 'block',\n};\nconst nodes = {\n    doc,\n    text,\n    paragraph,\n    blockquote,\n    horizontal_rule: horizontalRule,\n    heading,\n    hard_break: hardBreak,\n    code_block: codeBlock,\n    image,\n    list_item: listItem,\n    ordered_list: orderedList,\n    bullet_list: bulletList,\n};\n\nconst schema = new Schema({\n    marks,\n    nodes,\n});\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { marks, nodes, schema };\n\n"],
  "mappings": "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",
  "names": ["doc", "tr", "node", "listItem", "orderedList", "bulletList"]
}
